class StorageService {  constructor() {    this.prefix = "iss_tracker_";    this.defaultPreferences = {      theme: "dark",      autoUpdate: true,      updateInterval: 30000,      notifications: true,      units: "metric",      selectedView: "3d",      userLocation: null,      favoriteFeeds: [],      dashboardLayout: "default",      showOrbitalPath: true,      showGroundTrack: true,      autoRotate3D: true,      soundEnabled: false,      language: "en",    };  }  getPreferences() {    try {      const stored = localStorage.getItem(`${this.prefix}preferences`);      if (stored) {        const parsed = JSON.parse(stored);        return { ...this.defaultPreferences, ...parsed };      }      return this.defaultPreferences;    } catch (error) {      console.error("Error loading preferences:", error);      return this.defaultPreferences;    }  }  savePreferences(preferences) {    try {      const current = this.getPreferences();      const updated = { ...current, ...preferences };      localStorage.setItem(        `${this.prefix}preferences`,        JSON.stringify(updated)      );      return updated;    } catch (error) {      console.error("Error saving preferences:", error);      return this.getPreferences();    }  }  getPreference(key) {    const preferences = this.getPreferences();    return preferences[key];  }  setPreference(key, value) {    const preferences = this.getPreferences();    preferences[key] = value;    this.savePreferences(preferences);    return value;  }  cacheISSData(data, key = "current_data") {    try {      const cacheData = {        data,        timestamp: Date.now(),        expires: Date.now() + 5 * 60 * 1000, // 5 minutes      };      localStorage.setItem(        `${this.prefix}cache_${key}`,        JSON.stringify(cacheData)      );    } catch (error) {      console.error("Error caching data:", error);    }  }  getCachedISSData(key = "current_data") {    try {      const stored = localStorage.getItem(`${this.prefix}cache_${key}`);      if (stored) {        const cached = JSON.parse(stored);        if (cached.expires > Date.now()) {          return cached.data;        }        localStorage.removeItem(`${this.prefix}cache_${key}`);      }      return null;    } catch (error) {      console.error("Error loading cached data:", error);      return null;    }  }  saveUserLocation(location) {    this.setPreference("userLocation", location);  }  getUserLocation() {    return this.getPreference("userLocation");  }  saveViewingHistory(view) {    try {      const history = this.getViewingHistory();      const newEntry = {        view,        timestamp: Date.now(),        date: new Date().toISOString(),      };      const updated = [newEntry, ...history.slice(0, 49)]; // Keep last 50 entries      localStorage.setItem(        `${this.prefix}viewing_history`,        JSON.stringify(updated)      );    } catch (error) {      console.error("Error saving viewing history:", error);    }  }  getViewingHistory() {    try {      const stored = localStorage.getItem(`${this.prefix}viewing_history`);      return stored ? JSON.parse(stored) : [];    } catch (error) {      console.error("Error loading viewing history:", error);      return [];    }  }  saveFavoritePass(passData) {    try {      const favorites = this.getFavoritePasses();      const newFavorite = {        ...passData,        id: Date.now(),        saved: Date.now(),      };      const updated = [newFavorite, ...favorites.slice(0, 19)]; // Keep last 20      localStorage.setItem(        `${this.prefix}favorite_passes`,        JSON.stringify(updated)      );    } catch (error) {      console.error("Error saving favorite pass:", error);    }  }  getFavoritePasses() {    try {      const stored = localStorage.getItem(`${this.prefix}favorite_passes`);      return stored ? JSON.parse(stored) : [];    } catch (error) {      console.error("Error loading favorite passes:", error);      return [];    }  }  saveNotification(notification) {    try {      const notifications = this.getNotificationHistory();      const newNotification = {        ...notification,        id: notification.id || Date.now(),        timestamp: notification.timestamp || Date.now(),      };      const updated = [newNotification, ...notifications.slice(0, 99)]; // Keep last 100      localStorage.setItem(        `${this.prefix}notifications`,        JSON.stringify(updated)      );    } catch (error) {      console.error("Error saving notification:", error);    }  }  getNotificationHistory() {    try {      const stored = localStorage.getItem(`${this.prefix}notifications`);      return stored ? JSON.parse(stored) : [];    } catch (error) {      console.error("Error loading notifications:", error);      return [];    }  }  clearAllData() {    try {      const keys = Object.keys(localStorage);      keys.forEach((key) => {        if (key.startsWith(this.prefix)) {          localStorage.removeItem(key);        }      });      return true;    } catch (error) {      console.error("Error clearing data:", error);      return false;    }  }  exportData() {    try {      const data = {};      const keys = Object.keys(localStorage);      keys.forEach((key) => {        if (key.startsWith(this.prefix)) {          data[key] = localStorage.getItem(key);        }      });      return {        version: "1.0",        exported: new Date().toISOString(),        data,      };    } catch (error) {      console.error("Error exporting data:", error);      return null;    }  }  importData(importData) {    try {      if (!importData.data) return false;      Object.keys(importData.data).forEach((key) => {        localStorage.setItem(key, importData.data[key]);      });      return true;    } catch (error) {      console.error("Error importing data:", error);      return false;    }  }  getStorageInfo() {    try {      let totalSize = 0;      const items = {};      Object.keys(localStorage).forEach((key) => {        if (key.startsWith(this.prefix)) {          const size = new Blob([localStorage.getItem(key)]).size;          totalSize += size;          items[key.replace(this.prefix, "")] = {            size,            lastModified: "Unknown", // localStorage doesn't track modification time          };        }      });      return {        totalSize,        items,        maxSize: 5 * 1024 * 1024, // 5MB typical localStorage limit        usagePercentage: (totalSize / (5 * 1024 * 1024)) * 100,      };    } catch (error) {      console.error("Error getting storage info:", error);      return { totalSize: 0, items: {}, maxSize: 0, usagePercentage: 0 };    }  }  generateCacheKey(query) {    const normalized = query      .toLowerCase()      .trim()      .replace(/[^\w\s]/g, "")      .replace(/\s+/g, " ");    let hash = 0;    for (let i = 0; i < normalized.length; i++) {      const char = normalized.charCodeAt(i);      hash = (hash << 5) - hash + char;      hash = hash & hash; // Convert to 32-bit integer    }    return `chatbot_${Math.abs(hash)}`;  }  cacheChatbotResponse(query, response, metadata = {}) {    try {      const cacheKey = this.generateCacheKey(query);      const cacheData = {        query: query.trim(),        response,        metadata: {          timestamp: Date.now(),          responseTime: metadata.responseTime || 0,          tokenCount: metadata.tokenCount || response.length,          apiVersion: metadata.apiVersion || "gemini-2.5-flash",          ...metadata,        },        expires: Date.now() + 7 * 24 * 60 * 60 * 1000, // 7 days        hitCount: 1,        lastAccessed: Date.now(),      };      localStorage.setItem(        `${this.prefix}${cacheKey}`,        JSON.stringify(cacheData)      );      this.updateCacheStats("add");      return cacheKey;    } catch (error) {      console.error("Error caching chatbot response:", error);      return null;    }  }  getCachedChatbotResponse(query) {    try {      const cacheKey = this.generateCacheKey(query);      const stored = localStorage.getItem(`${this.prefix}${cacheKey}`);      if (!stored) return null;      const cached = JSON.parse(stored);      if (cached.expires < Date.now()) {        localStorage.removeItem(`${this.prefix}${cacheKey}`);        this.updateCacheStats("expire");        return null;      }      cached.hitCount = (cached.hitCount || 0) + 1;      cached.lastAccessed = Date.now();      localStorage.setItem(`${this.prefix}${cacheKey}`, JSON.stringify(cached));      this.updateCacheStats("hit");      return {        response: cached.response,        metadata: cached.metadata,        fromCache: true,        hitCount: cached.hitCount,      };    } catch (error) {      console.error("Error retrieving cached response:", error);      return null;    }  }  findSimilarCachedResponses(query, threshold = 0.7) {    try {      const results = [];      const queryWords = query.toLowerCase().trim().split(/\s+/);      Object.keys(localStorage).forEach((key) => {        if (key.startsWith(`${this.prefix}chatbot_`)) {          try {            const cached = JSON.parse(localStorage.getItem(key));            if (cached.expires < Date.now()) return; // Skip expired            const cachedWords = cached.query.toLowerCase().split(/\s+/);            const similarity = this.calculateSimilarity(              queryWords,              cachedWords            );            if (similarity >= threshold) {              results.push({                similarity,                response: cached.response,                originalQuery: cached.query,                metadata: cached.metadata,              });            }          } catch {          }        }      });      return results.sort((a, b) => b.similarity - a.similarity);    } catch (error) {      console.error("Error finding similar responses:", error);      return [];    }  }  calculateSimilarity(words1, words2) {    const set1 = new Set(words1);    const set2 = new Set(words2);    const intersection = new Set([...set1].filter((x) => set2.has(x)));    const union = new Set([...set1, ...set2]);    return intersection.size / union.size; // Jaccard similarity  }  updateCacheStats(action) {    try {      const stats = this.getCacheStats();      switch (action) {        case "add":          stats.totalCached++;          break;        case "hit":          stats.cacheHits++;          break;        case "miss":          stats.cacheMisses++;          break;        case "expire":          stats.expired++;          break;      }      stats.lastUpdated = Date.now();      stats.hitRate =        (stats.cacheHits / (stats.cacheHits + stats.cacheMisses)) * 100;      localStorage.setItem(`${this.prefix}cache_stats`, JSON.stringify(stats));    } catch (error) {      console.error("Error updating cache stats:", error);    }  }  getCacheStats() {    try {      const stored = localStorage.getItem(`${this.prefix}cache_stats`);      if (stored) {        return JSON.parse(stored);      }      return {        totalCached: 0,        cacheHits: 0,        cacheMisses: 0,        expired: 0,        hitRate: 0,        lastUpdated: Date.now(),      };    } catch (error) {      console.error("Error getting cache stats:", error);      return {        totalCached: 0,        cacheHits: 0,        cacheMisses: 0,        expired: 0,        hitRate: 0,        lastUpdated: Date.now(),      };    }  }  cleanExpiredChatbotCache() {    try {      let cleanedCount = 0;      const keys = Object.keys(localStorage);      keys.forEach((key) => {        if (key.startsWith(`${this.prefix}chatbot_`)) {          try {            const cached = JSON.parse(localStorage.getItem(key));            if (cached.expires < Date.now()) {              localStorage.removeItem(key);              cleanedCount++;            }          } catch {            localStorage.removeItem(key);            cleanedCount++;          }        }      });      if (cleanedCount > 0) {        this.updateCacheStats("expire");      }      return cleanedCount;    } catch (error) {      console.error("Error cleaning expired cache:", error);      return 0;    }  }  clearChatbotCache() {    try {      let clearedCount = 0;      Object.keys(localStorage).forEach((key) => {        if (key.startsWith(`${this.prefix}chatbot_`)) {          localStorage.removeItem(key);          clearedCount++;        }      });      localStorage.removeItem(`${this.prefix}cache_stats`);      return clearedCount;    } catch (error) {      console.error("Error clearing chatbot cache:", error);      return 0;    }  }}export const storageService = new StorageService();export default storageService;