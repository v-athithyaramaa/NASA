class RedisService {  constructor() {    this.baseURL = "http://localhost:3001/api";    this.sessionId = this.getOrCreateSessionId();    this.isOnline = true;    this.retryCount = 0;    this.maxRetries = 3;    this.testConnection();  }  getOrCreateSessionId() {    let sessionId = localStorage.getItem("iss_chat_session_id");    if (!sessionId) {      sessionId = `session_${Date.now()}_${Math.random()        .toString(36)        .substr(2, 9)}`;      localStorage.setItem("iss_chat_session_id", sessionId);    }    return sessionId;  }  async testConnection() {    try {      const response = await fetch(        `${this.baseURL.replace("/api", "")}/health`      );      const data = await response.json();      this.isOnline = data.status === "healthy";      this.retryCount = 0;      console.log("✅ Redis server connection:", data);    } catch (error) {      this.isOnline = false;      console.warn(        "⚠️ Redis server offline, using fallback mode:",        error.message      );    }  }  async makeRequest(endpoint, options = {}) {    if (!this.isOnline && this.retryCount < this.maxRetries) {      await this.testConnection();      this.retryCount++;    }    if (!this.isOnline) {      throw new Error("Redis server unavailable");    }    try {      const response = await fetch(`${this.baseURL}${endpoint}`, {        headers: {          "Content-Type": "application/json",          ...options.headers,        },        ...options,      });      if (!response.ok) {        throw new Error(`HTTP ${response.status}: ${response.statusText}`);      }      return await response.json();    } catch (error) {      this.isOnline = false;      throw error;    }  }  generateCacheKey(query) {    const normalized = query      .toLowerCase()      .trim()      .replace(/[^\w\s]/g, "")      .replace(/\s+/g, " ");    let hash = 0;    for (let i = 0; i < normalized.length; i++) {      const char = normalized.charCodeAt(i);      hash = (hash << 5) - hash + char;      hash = hash & hash; // Convert to 32-bit integer    }    return `chatbot:${Math.abs(hash).toString(16)}`;  }  async cacheChatbotResponse(query, response, metadata = {}) {    try {      await this.makeRequest("/cache", {        method: "POST",        body: JSON.stringify({          query: query.trim(),          response,          metadata: {            timestamp: Date.now(),            responseTime: metadata.responseTime || 0,            tokenCount: metadata.tokenCount || response.length,            apiVersion: metadata.apiVersion || "gemini-2.5-flash",            ...metadata,          },        }),      });      return true;    } catch (error) {      console.warn("Failed to cache response:", error.message);      return false;    }  }  async getCachedChatbotResponse(query) {    try {      const encodedQuery = encodeURIComponent(query);      const result = await this.makeRequest(`/cache/${encodedQuery}`);      if (result.found) {        return {          response: result.response,          metadata: result.metadata,          fromCache: true,          hitCount: result.hitCount,          lastAccessed: result.lastAccessed,        };      }      return null;    } catch (error) {      console.warn("Failed to retrieve cached response:", error.message);      return null;    }  }  async findSimilarCachedResponses(query, threshold = 0.7) {    try {      const result = await this.makeRequest("/cache/similar", {        method: "POST",        body: JSON.stringify({ query, threshold }),      });      return result.found ? result.matches : [];    } catch (error) {      console.warn("Failed to find similar responses:", error.message);      return [];    }  }  async getCacheStatistics() {    try {      return await this.makeRequest("/cache/stats");    } catch (error) {      console.warn("Failed to get cache statistics:", error.message);      return {        totalCached: 0,        cacheHits: 0,        cacheMisses: 0,        hitRate: 0,        lastUpdated: Date.now(),      };    }  }  async clearCache() {    try {      const result = await this.makeRequest("/cache/clear", {        method: "DELETE",      });      return result.success;    } catch (error) {      console.warn("Failed to clear cache:", error.message);      return false;    }  }  async getAllCachedResponses() {    try {      return await this.makeRequest("/cache/all");    } catch (error) {      console.warn("Failed to get all cached responses:", error.message);      return { total: 0, responses: [] };    }  }  async saveChatHistory(messages) {    try {      await this.makeRequest("/chat/history", {        method: "POST",        body: JSON.stringify({          sessionId: this.sessionId,          messages,        }),      });      return true;    } catch (error) {      console.warn("Failed to save chat history:", error.message);      return false;    }  }  async loadChatHistory() {    try {      const result = await this.makeRequest(`/chat/history/${this.sessionId}`);      if (result.found) {        return {          messages: result.messages,          messageCount: result.messageCount,          lastUpdated: result.lastUpdated,        };      }      return { messages: [] };    } catch (error) {      console.warn("Failed to load chat history:", error.message);      return { messages: [] };    }  }  isServerOnline() {    return this.isOnline;  }  getSessionId() {    return this.sessionId;  }  resetSession() {    localStorage.removeItem("iss_chat_session_id");    this.sessionId = this.getOrCreateSessionId();    return this.sessionId;  }  getFallbackStorage() {    return {      cache: JSON.parse(localStorage.getItem("iss_fallback_cache") || "{}"),      history: JSON.parse(localStorage.getItem("iss_fallback_history") || "[]"),      stats: JSON.parse(        localStorage.getItem("iss_fallback_stats") ||          '{"totalCached":0,"cacheHits":0,"cacheMisses":0,"hitRate":0}'      ),    };  }  saveFallbackStorage(type, data) {    localStorage.setItem(`iss_fallback_${type}`, JSON.stringify(data));  }  async getResponse(query) {    let cached = await this.getCachedChatbotResponse(query);    if (cached) {      return cached;    }    const similar = await this.findSimilarCachedResponses(query, 0.8);    if (similar.length > 0) {      return {        response: similar[0].response,        metadata: similar[0].metadata,        fromCache: true,        similarity: similar[0].similarity,        originalQuery: similar[0].originalQuery,      };    }    return null;  }}export default RedisService;