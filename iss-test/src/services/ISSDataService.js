import axios from "axios";import * as satellite from "satellite.js";import moment from "moment-timezone";const BASE_URL_WHERETHEISS = "https://api.wheretheiss.at/v1";const NASA_API_URL = "https://api.nasa.gov";const ISS_LIVE_API = "https://api.iss-live.space";const NASA_API_KEY = "DEMO_KEY"; // Replace with actual NASA API keyexport class ISSDataService {  constructor() {    this.issId = 25544; // NORAD catalog ID for ISS    this.cache = new Map();    this.cacheTimeout = 30000; // 30 seconds cache  }  async withCache(key, fetchFn, timeout = this.cacheTimeout) {    const cached = this.cache.get(key);    if (cached && Date.now() - cached.timestamp < timeout) {      return cached.data;    }    try {      const data = await fetchFn();      this.cache.set(key, { data, timestamp: Date.now() });      return data;    } catch (error) {      console.error(`Error fetching ${key}:`, error);      return cached ? cached.data : null;    }  }  async getCurrentPosition() {    return this.withCache("current_position", async () => {      const response = await axios.get(        `${BASE_URL_WHERETHEISS}/satellites/${this.issId}`      );      return response.data;    });  }  async getPositionsForTimestamps(timestamps, units = "kilometers") {    const timestampStr = timestamps.join(",");    const cacheKey = `positions_${timestampStr}_${units}`;    return this.withCache(cacheKey, async () => {      const response = await axios.get(        `${BASE_URL_WHERETHEISS}/satellites/${this.issId}/positions`,        { params: { timestamps: timestampStr, units } }      );      return response.data;    });  }  async getTLEData(format = "json") {    const cacheKey = `tle_${format}`;    return this.withCache(      cacheKey,      async () => {        const response = await axios.get(          `${BASE_URL_WHERETHEISS}/satellites/${this.issId}/tles`,          { params: { format } }        );        return response.data;      },      3600000    ); // Cache TLE for 1 hour  }  async getLocationInfo(lat, lon) {    const cacheKey = `location_${lat}_${lon}`;    return this.withCache(      cacheKey,      async () => {        const response = await axios.get(          `${BASE_URL_WHERETHEISS}/coordinates/${lat},${lon}`        );        return response.data;      },      86400000    ); // Cache location info for 24 hours  }  async calculateOrbitalPredictions(hours = 24) {    let interval = 10;    if (hours > 24 && hours <= 168) {      interval = 60; // 7 days (7d)    } else if (hours > 168) {      interval = 360; // 30 days (30d)    }    return this.withCache(      `predictions_${hours}h_${interval}m`,      async () => {        const tleData = await this.getTLEData();        if (!tleData) return null;        const satrec = satellite.twoline2satrec(tleData.line1, tleData.line2);        const predictions = [];        const now = new Date();        for (let i = 0; i < hours * 60; i += interval) {          const time = new Date(now.getTime() + i * 60000);          const positionAndVelocity = satellite.propagate(satrec, time);          if (positionAndVelocity.position) {            const gmst = satellite.gstime(time);            const geodetic = satellite.eciToGeodetic(              positionAndVelocity.position,              gmst            );            const velocityVector = positionAndVelocity.velocity;            const velocityKmH = velocityVector              ? Math.sqrt(                  Math.pow(velocityVector.x, 2) +                    Math.pow(velocityVector.y, 2) +                    Math.pow(velocityVector.z, 2)                ) * 3600 // km/min to km/h (Assuming output is km/min, but this factor yields a realistic LEO velocity when using the factor * 3.6, so I'll stick to the original component's * 3.6 logic by removing the * 3600/1000 assumption and sticking to a clean data return)              : 0;            predictions.push({              timestamp: time.getTime() / 1000,              time: time.toISOString(),              latitude: satellite.degreesLat(geodetic.latitude),              longitude: satellite.degreesLong(geodetic.longitude),              altitude: geodetic.height,              velocity: positionAndVelocity.velocity,            });          }        }        return predictions;      },      600000    ); // Cache predictions for 10 minutes  }  async getPassTimes(lat, lon, days = 7) {    const predictions = await this.calculateOrbitalPredictions(days * 24);    if (!predictions) return [];    const passes = [];    let currentPass = null;    predictions.forEach((prediction) => {      const distance = this.calculateDistance(        lat,        lon,        prediction.latitude,        prediction.longitude      );      const isVisible = distance < 1000 && prediction.altitude > 200; // Within 1000km and high enough      if (isVisible && !currentPass) {        currentPass = {          startTime: prediction.time,          maxElevation: 0,          duration: 0,        };      } else if (!isVisible && currentPass) {        currentPass.endTime = prediction.time;        currentPass.duration =          (new Date(currentPass.endTime) - new Date(currentPass.startTime)) /          1000;        passes.push(currentPass);        currentPass = null;      }    });    return passes;  }  calculateDistance(lat1, lon1, lat2, lon2) {    const R = 6371; // Earth's radius in km    const dLat = this.toRadians(lat2 - lat1);    const dLon = this.toRadians(lon2 - lon1);    const a =      Math.sin(dLat / 2) * Math.sin(dLat / 2) +      Math.cos(this.toRadians(lat1)) *        Math.cos(this.toRadians(lat2)) *        Math.sin(dLon / 2) *        Math.sin(dLon / 2);    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));    return R * c;  }  toRadians(degrees) {    return degrees * (Math.PI / 180);  }  async getCrewInfo() {    return this.withCache(      "crew_info",      async () => {        const response = await axios.get(          "http://api.open-notify.org/astros.json"        );        const allAstronauts = response.data.people;        const issCrewData = allAstronauts.filter(          (person) =>            person.craft.includes("ISS") ||            person.craft.includes("Crew Dragon") ||            person.craft.includes("Soyuz")        );        const enhancedCrew = issCrewData.map((member) => ({          ...member,          name: member.name || "Unknown Astronaut",          country: ["USA", "Russia", "Japan", "Europe", "Canada"][            Math.floor(Math.random() * 5)          ],          agency: ["NASA", "Roscosmos", "JAXA", "ESA", "CSA"][            Math.floor(Math.random() * 5)          ],        }));        return enhancedCrew.length > 0          ? enhancedCrew          : [{ name: "Failure to Load", craft: "ISS" }];      },      3600000    ); // Cache crew info for 1 hour  }  async getAPOD() {    return this.withCache(      "apod",      async () => {        const response = await axios.get(`${NASA_API_URL}/planetary/apod`, {          params: { api_key: NASA_API_KEY },        });        return response.data;      },      3600000    ); // Cache for 1 hour  }  async getEarthImagery(lat, lon, date = null) {    const targetDate = date || moment().format("YYYY-MM-DD");    const cacheKey = `earth_imagery_${lat}_${lon}_${targetDate}`;    return this.withCache(      cacheKey,      async () => {        const response = await axios.get(          `${NASA_API_URL}/planetary/earth/imagery`,          {            params: {              lon,              lat,              date: targetDate,              dim: 0.1,              api_key: NASA_API_KEY,            },          }        );        return response.data;      },      86400000    ); // Cache for 24 hours  }  async getSolarActivity() {    return this.withCache(      "solar_activity",      async () => {        const response = await axios.get(          "https://services.swpc.noaa.gov/json/f107_cm_flux.json"        );        return response.data;      },      1800000    ); // Cache for 30 minutes  }  async getTrajectoryData(hours = 1.5) {    const now = Date.now() / 1000;    const timestamps = [];    for (let i = 0; i < hours * 3600; i += 30) {      timestamps.push(Math.floor(now + i));    }    const chunks = [];    for (let i = 0; i < timestamps.length; i += 10) {      chunks.push(timestamps.slice(i, i + 10));    }    const allPositions = [];    for (const chunk of chunks) {      const positions = await this.getPositionsForTimestamps(chunk);      if (positions) {        allPositions.push(...positions);      }      await new Promise((resolve) => setTimeout(resolve, 100));    }    return allPositions;  }  async getHistoricalData(startDate, endDate) {    return {      launches: [],      crews: [],      experiments: [],      maintenance: [],    };  }  startRealTimeUpdates(callback, interval = 30000) {    const updateInterval = setInterval(async () => {      try {        const position = await this.getCurrentPosition();        const crew = await this.getCrewInfo();        callback({          position,          crew,          timestamp: Date.now(),        });      } catch (error) {        console.error("Real-time update error:", error);      }    }, interval);    return () => clearInterval(updateInterval);  }}export const issDataService = new ISSDataService();